{"constants":[{"id":"constant-1","name":"SlackWebHook","hidden":false,"value":""},{"id":"constant-2","name":"QTEST_TOKEN","hidden":false,"value":""},{"id":"constant-3","name":"ManagerURL","hidden":false,"value":""},{"id":"constant-4","name":"JenkinsAPIToken","hidden":false,"value":""},{"id":"constant-5","name":"JenkinsURL","hidden":false,"value":""},{"id":"constant-6","name":"JenkinsUserName","hidden":false,"value":""},{"id":"constant-7","name":"Scenario_URL","hidden":false,"value":""},{"id":"constant-8","name":"JenkinsJobToken","hidden":false,"value":""},{"id":"constant-9","name":"SCENARIO_PROJECT_ID","hidden":false,"value":""},{"id":"constant-10","name":"JenkinsJobName","hidden":false,"value":""}],"actions":[{"id":"action-1","name":"FormatJavaCucumber","description":"","code":"const { Webhooks } = require('@qasymphony/pulse-sdk');\n\n// Returns an array of step names\nconst getStepNames = testCase => testCase.steps.map(step => step.name);\n\n// Create a deep clone of object when wanting to avoid mutating original data, this method is only safe if the supplied object is 100% parsable in JSON\nconst createDeepCloneOfJsonObject = object => JSON.parse(JSON.stringify(object));\n\n// Injects the step name into the attachment object, relying on the context of 'this' to be set to a step object \n// e.g. an arrow function cannot be used\nconst injectStepName = function(attachment) {\n    attachment.step_name = (\"name\" in this) ? this.name : \"\";\n    return attachment;\n} \n\n// Creates a clone of the step before iterating through the attachments contained within it, adding a 'step_name' field\nconst attachmentsWithStepNameInjected = (step) => createDeepCloneOfJsonObject(step).embeddings.map(injectStepName, step);\n\n// Flattens a multidimensional array, into a simple array by storing each value in the accumulator\nconst flattenArray = (acc, arrayValue) => acc.concat(arrayValue);\n\n// Checks that the passed in object contains an embeddings field\nconst hasEmbeddings = object => \"embeddings\" in object;\n\n// Creates an attachment object, using the passed in attachment and index values\nconst attachmentInformation = (attachment, index) => { \n    return { \n                name: `${attachment.step_name} Attachment ${index + 1}`,\n                \"content_type\": attachment.mime_type,\n                data: attachment.data\n            }\n};\n\n// Iterates over each step and grabs all attachments and returns a flat array containing the attachment information\nconst getStepAttachments = testCase => testCase.steps.filter(hasEmbeddings).map(attachmentsWithStepNameInjected)\n    .reduce(flattenArray, []).map(attachmentInformation);\n\n// Iterates over each hook and grabs all attachments and returns a flat array containing the attachment information\nconst getHookAttachments = testCase => (\"after\" in testCase) ? testCase.after.filter(hasEmbeddings).map(attachmentsWithStepNameInjected)\n    .reduce(flattenArray, []).map(attachmentInformation) : [];\n\n// Grabs all attachments from the hooks and steps and combines them into a single flat array of attachment information\nconst getAllAttachments = testCase => getStepAttachments(testCase).concat(getHookAttachments(testCase));\n\n// Enum object to handle possible statuses within cucumber json output and in qTest Manager\nconst Status = {\n    PASSED: \"passed\",\n    FAILED: \"failed\",\n    SKIPPED: \"skipped\",\n    UNDEFINED: \"undefined\",\n    PENDING: \"pending\",\n    BLOCKED: \"blocked\",\n}\n\n// Calculates the overall testcase status based on the result of the passed in step, storing the result in the accumulator\nconst testCaseStatus = (acc, step) => (Status.PASSED === acc) ? step.result.status: acc;\n\n// Gets the testcase status based on the result of each step\nconst getTCStatus = testCase => testCase.steps.reduce(testCaseStatus, Status.PASSED);\n\n// Returns an  actual result based on step.result.status\n// A step is skipped when a previous step, background step or before hook fails\n// A step is undefined when it exists in a feature but no definition is found\n// A step is pending when it exists in a feature file, has a defition, but explicitly throws a PendingException\nconst getActualResult = step => {\n    return {\n        [Status.PASSED]: step.name,\n        [Status.FAILED]: step.result.error_message,\n        [Status.SKIPPED]: \"This step has been skipped due to a previous failure\",\n        [Status.UNDEFINED]: \"This step does not match any step definitions\",\n        [Status.PENDING]: \"This step is marked as pending\"\n    }[step.result.status];\n}\n\n// Generates a step log object for injection into a test log\nconst testStepLogs = testCase => testCase.steps.map((step, index) => {\n    return {\n        order: index,\n        description: `${step.keyword}`,\n        expected_result: step.name,\n        actual_result: getActualResult(step),\n        status: step.result.status\n    };\n});\n\n// Injects the feature name and URI into the test case object, relying on the context of 'this' to be set to a test case object \n// e.g. an arrow function cannot be used\nconst injectFeatureNameAndUri = function(testCase) {\n    testCase.feature_uri = this.uri;\n    testCase.feature_name = this.name;\n    return testCase;\n}\n\n// Creates a clone of the feature before iterating through the test cases contained within it, adding the 'feature_name' and 'feature_uri' fields.\nconst testCasesWithFeatureNameAndUriInjected = feature => createDeepCloneOfJsonObject(feature).elements.map(injectFeatureNameAndUri, feature);\n\n// gets all of the folders after the 'features' directory\nvar getModules = URI => {\n    let modules = [\"Features\"].concat(URI.replace(/.+features\\//i,\"\").split(\"/\"));\n    modules.pop();\n    return modules;\n}\n\n// Create a new object to represent a test log and populate it's fields\nconst testLogs = testCase => ({\n            exe_start_date: new Date(), // TODO These could be passed in\n            exe_end_date: new Date(),\n            module_names: getModules(testCase.feature_uri),\n            name: \"name\" in testCase ? testCase.name : \"Unnamed\",\n            automation_content: testCase.feature_uri + \"#\" + testCase.name,\n            attachments: getAllAttachments(testCase),\n            status: getTCStatus(testCase),\n            test_step_logs: testStepLogs(testCase),\n            featureName: testCase.feature_name,\n        });\n\n// Loops through all of the features and test cases creating a test log for each\nconst generateTestLogs = features => features.map(testCasesWithFeatureNameAndUriInjected).reduce(flattenArray, []).map(testLogs);\n\n// Entry point to the script, it takes the cucumber json input and reformat it into qTest Manager friendly\n// json before handing it off to the down stream rule\nexports.handler = ({ event: body, constants, triggers }, context, callback) => {\n\n    const emitEvent = (name, payload) => {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    const payload = body;\n\n    const formattedResults = {\n        \"projectId\": payload.projectId,\n        \"test-cycle\": payload[\"test-cycle\"],\n        \"logs\": generateTestLogs(payload.result)\n    };\n\n    // Pulse Version\n    // Emit next fxn to upload results/parse\n    emitEvent('UpdateQTestWithFormattedResultsEvent', formattedResults);\n}"},{"id":"action-2","name":"UpdateQTestWithFormattedResults","description":"","code":"const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\nconst ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconst Features = {\n    getIssueLinkByFeatureName(qtestToken, scenarioProjectId, name) {\n        return new ScenarioSdk.Features({ qtestToken, scenarioProjectId }).getFeatures(`\"${name}\"`);\n    }\n};\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    // Specific to pulse actions\n    var payload = body;\n\n    var testLogs = payload.logs;\n    var cycleId = payload[\"test-cycle\"];\n    var projectId = payload.projectId;\n\n    var scenarioCount = 0;\n    var scenarioList = \"\";\n\n    var standardHearders = {\n        'Content-Type': 'application/json',\n        'Authorization': `bearer ${constants.QTEST_TOKEN}`\n    }\n\n    var createLogsAndTCs = function () {\n        var opts = {\n            url: \"http://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/auto-test-logs?type=automation\",\n            json: true,\n            headers: standardHearders,\n            body: {\n                test_cycle: cycleId,\n                test_logs: testLogs\n            }\n        };\n\n        return request.post(opts, function (err, response, resbody) {\n\n            if (err) {\n                Promise.reject(err);\n            }\n            else {\n                console.log('response from qTest Manager:', JSON.stringify(response))\n                emitEvent('SlackEvent', { AutomationLogUploaded: resbody });\n\n                if (response.body.type == \"AUTOMATION_TEST_LOG\") {\n                    Promise.resolve(\"Uploaded results successfully\");\n                }\n                else {\n                    emitEvent('SlackEvent', { Error: \"Wrong type\" });\n                    Promise.reject(\"Unable to upload test results\");\n                }\n            }\n        });\n    };\n\n    createLogsAndTCs()\n        .on('response', function () {\n            console.log(\"About to call Link Requirements Rule\")\n            emitEvent('LinkScenarioRequirements', payload);\n            //linkReq();\n        })\n        .on('error', function (err) {\n            emitEvent('SlackEvent', { CaughtError: err });\n        })\n}"},{"id":"action-3","name":"LinkScenarioRequirements","description":null,"code":"const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\nconst ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconsole.log(\"Starting Link Requirements Action\");\n    \nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    \n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n    // Specific to pulse actions\n    var payload = body;\n\n    var testLogs = payload.logs;\n    var projectId = payload.projectId;\n\n    var standardHeaders = {\n        'Content-Type': 'application/json',\n        'Authorization': `bearer ${constants.QTEST_TOKEN}`,\n        'x-scenario-project-id': constants.SCENARIO_PROJECT_ID\n    }\n\n    const options = {\n        url: constants.Scenario_URL + 'features',\n        method: 'GET',\n        headers: standardHeaders\n    };\n\n    var features;\n    console.log(\"Getting feature list options: \" + options);\n    request.get(options, function (optserr, optsresponse, resbody) {\n        if (optserr) {\n            console.log(\"Problem Getting Feature List: \" + optserr);\n        }\n        else {\n            console.log(\"Got Features List: \" + resbody);\n            features = JSON.parse(resbody);\n            LinkRequirements();\n        }\n    });\n    \n    // This makes a best effort to link if test cases exist. Not if you just uploaded via the auto-test-logs endpoint, the job is batched and may not be completed yet\n    function LinkRequirements() {\n        testLogs.forEach(function (testcase) {\n        \n        var matchingFeature = features.find(x => x.name === testcase.featureName);\n\n        if(!matchingFeature)\n            return;\n            \n        var reqopts = getReqBody(matchingFeature.issueKey);\n        request.post(reqopts, function (err, response, featureResBody) {\n\n            if (err) {\n                emitEvent('SlackEvent', { Error: \"Problem getting requirement: \" + err });\n            }\n            else {\n                if (featureResBody.items.length === 0) // No corresponding feature exists in scenario\n                    return;\n\n                var reqid = featureResBody.items[0].id;\n                var tcopts = getTCBody(testcase.name);\n\n                request.post(tcopts, function (tcerr, tcresponse, testCaseResBody) {\n\n                    if (tcerr) {\n                        emitEvent('SlackEvent', { Error: \"Problem getting test case: \" + err });\n                    }\n                    else {\n                        if(testCaseResBody.items.length === 0) // Test Case Doesn't yet exist - we'll try this another time\n                            return;\n\n                        var tcid = testCaseResBody.items[0].id;\n                        var linkopts = getLinkBody(reqid, tcid);\n\n                        request.post(linkopts, function (optserr, optsresponse, resbody) {\n                            if (optserr) {\n                                emitEvent('SlackEvent', { Error: \"Problem creating test link to requirement: \" + err });\n                            }\n                            else {\n                                // Success, we added a link!\n                                emitEvent('SlackEvent', { Linking: \"link added for TC: \" + testcase.name + \" to requirement \" + matchingFeature.issueKey });\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    });\n\n    }\n\n    function getTCBody(TCName) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/search\",\n            json: true,\n            headers: standardHeaders,\n            body: {\n                \"object_type\": \"test-cases\",\n                \"fields\": [\n                    \"*\"\n                ],\n                \"query\": \"Name = '\" + TCName + \"'\"\n            }\n        };\n    }\n\n    function getReqBody(key) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/search\",\n            json: true,\n            headers: standardHeaders,\n            body: {\n                \"object_type\": \"requirements\",\n                \"fields\": [\n                    \"*\"\n                ],\n                \"query\": \"Name ~ '\" + key + \"'\"\n            }\n        };\n    }\n\n    function getLinkBody(reqid, tcid) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/requirements/\" + reqid + \"/link?type=test-cases\",\n            json: true,\n            headers: standardHeaders,\n            body: [\n                tcid\n            ]\n        };\n    }\n}\n"},{"id":"action-4","name":"triggerJenkins","description":null,"code":"const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    var url = \"http://\" + constants.JenkinsUserName + \":\" + constants.JenkinsAPIToken + \"@\" +\n        constants.JenkinsURL + '/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,\":\",//crumb)';\n\n    request.get({ url: url, insecure: true }, function (err, response, body) {\n        if (!err) {\n            var crumb = body.split(\":\")[1];\n\n            var joburl = \"http://\" + constants.JenkinsUserName + \":\" + constants.JenkinsAPIToken + \"@\" +\n                constants.JenkinsURL + \"/job/\" + constants.JenkinsJobName + \"/build?token=\" + constants.JenkinsJobToken\n            var opts = {\n                url: joburl,\n                insecure: true,\n                contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n                headers: {\n                    \"Jenkins-Crumb\": crumb\n                }\n            }\n\n            request.post(opts, function (err, res, bd) {\n                emitEvent('SlackEvent', { JenkinsCallSuccess: \"Jenkins Build just kicked off for project \" + constants.JenkinsJobName });\n            })\n        }\n    })\n}\n"},{"id":"action-5","name":"SlackAction","description":null,"code":"exports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    var str = body;\n\n    var request = require('request');\n    var slack_webhook = constants.SlackWebHook;\n\n    console.log('About to request slack webhook: ', slack_webhook);\n\n    request({\n        uri: slack_webhook,\n        method: 'POST',\n        json: { \"text\": JSON.stringify(str) }\n    }, function (error, response, body) { }\n    );\n}\n"},{"id":"action-6","name":"scenarioColors","description":null,"code":"const ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconst StepSdk = {\n    getStepSdk(qtestToken, scenarioProjectId) {\n        return new ScenarioSdk.Steps({ qtestToken, scenarioProjectId });\n    }\n}\n\nconst Steps = {\n    updateStepResults(stepSdk, name, status) {\n        return stepSdk.getSteps(`\"${name}\"`).\n            then(steps => Promise.all(steps.map(step => stepSdk.updateStep(step.id, Object.assign(step, { status })))))\n            .catch(function (err) {\n                console.log(\"Name: \" + name + \" : STATUS:  \" + status);\n                console.log('Error updating colors: ' + err);\n            });\n    }\n};\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    var payload = body;\n    var testLogs = payload.logs;\n\n    stepSdk = StepSdk.getStepSdk(constants.QTEST_TOKEN, constants.SCENARIO_PROJECT_ID);\n    \n    for (var res of testLogs) {\n        for (var step of res[\"test_step_logs\"]) {\n            var stepName = step.description;\n            var stepStatus = step.status;\n\n            // Undefined means no step definition existed and it should fail\n            if (stepStatus == \"undefined\") {\n                stepStatus = \"failed\";\n            }\n\n            // one of PASSED (green), FAILED (red), or SKIPPED (yellow)\n            stepStatus = stepStatus.toUpperCase();\n\n            // Call the pulse API to update step results\n            Steps.updateStepResults(stepSdk, stepName, stepStatus);\n        }\n    }\n}\n"}],"triggers":[{"id":"trigger-1","name":"scenarioColors"},{"id":"trigger-2","name":"SlackEvent"},{"id":"trigger-3","name":"UpdateQTestWithFormattedResultsEvent"},{"id":"trigger-4","name":"triggerJenkins"},{"id":"trigger-5","name":"LinkScenarioRequirements"},{"id":"trigger-6","name":"UploadJavaCucumberResults"}],"rules":[{"id":"rule-7","name":"MessageSlack","active":true,"triggerId":"trigger-2","actionIds":["action-5"],"tags":[]},{"id":"rule-8","name":"triggerJenkins","active":true,"triggerId":"trigger-4","actionIds":["action-4"],"tags":[]},{"id":"rule-9","name":"UploadJavaCucumberResultsWithScenario","active":true,"triggerId":"trigger-3","actionIds":["action-6","action-2"],"tags":[]},{"id":"rule-10","name":"LinkTestCasesToRequirementsWithScenario","active":true,"triggerId":"trigger-5","actionIds":["action-3"],"tags":[]},{"id":"rule-11","name":"UploadJavaCucumberResults","active":true,"triggerId":"trigger-6","actionIds":["action-1"],"tags":[]}]}