{
  "constants": [
    {
      "id": "constant-1",
      "name": "Scenario_URL",
      "hidden": false,
      "value": ""
    },
    {
      "id": "constant-2",
      "name": "SlackWebHook",
      "hidden": false,
      "value": ""
    },
    {
      "id": "constant-3",
      "name": "JenkinsURL",
      "hidden": false,
      "value": ""
    },
    {
      "id": "constant-4",
      "name": "ManagerURL",
      "hidden": false,
      "value": ""
    },
    {
      "id": "constant-5",
      "name": "JenkinsJobName",
      "hidden": false,
      "value": ""
    },
    {
      "id": "constant-6",
      "name": "QTEST_TOKEN",
      "hidden": false,
      "value": ""
    },
    {
      "id": "constant-7",
      "name": "SlackWebHook",
      "hidden": false,
      "value": ""
    },
    {
      "id": "constant-8",
      "name": "JenkinsJobToken",
      "hidden": false,
      "value": ""
    },
    {
      "id": "constant-9",
      "name": "JenkinsAPIToken",
      "hidden": false,
      "value": ""
    },
    {
      "id": "constant-10",
      "name": "JenkinsUserName",
      "hidden": false,
      "value": ""
    },
    {
      "id": "constant-11",
      "name": "SCENARIO_PROJECT_ID",
      "hidden": false,
      "value": ""
    },
    {
      "id": "constant-12",
      "name": "ProjectID",
      "hidden": false,
      "value": ""
    }
  ],
  "actions": [
    {
      "id": "action-1",
      "name": "FormatJavaCucumber",
      "description": null,
      "code": "const { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    // Payload to be passed in: json style cucumber for java test results\n\n    /////// Pulse version\n    var payload = body;\n    var testResults = payload.result;\n    var projectId = payload.projectId;\n    var cycleId = payload[\"test-cycle\"];\n\n    var testLogs = [];\n    console.log(\"TEST RESULTS: \" + testResults);\n\n    //emitEvent('SlackEvent', { TESTRESULTS: testResults });\n\n    testResults.forEach(function (feature) {\n        var featureName = feature.name;\n        feature.elements.forEach(function (testCase) {\n\n            if (!testCase.name)\n                testCase.name = \"Unnamed\";\n\n            TCStatus = \"passed\";\n\n            var reportingLog = {\n                exe_start_date: new Date(), // TODO These could be passed in\n                exe_end_date: new Date(),\n                module_names: [\n                    'Test Scenarios'\n                ],\n                name: testCase.name,\n                automation_content: feature.uri + \"#\" + testCase.name\n            };\n\n            var testStepLogs = [];\n            order = 0;\n            stepNames = [];\n            attachments = [];\n\n            testCase.steps.forEach(function (step) {\n                stepNames.push(step.name);\n\n                var status = step.result.status;\n                var actual = step.name;\n\n                if (TCStatus == \"passed\" && status == \"skipped\") {\n                    TCStatus = \"skipped\";\n                }\n                if (status == \"failed\") {\n                    TCStatus = \"failed\";\n                    actual = step.result.error_message;\n                }\n                if (status == \"undefined\") {\n                    TCStatus = \"failed\";\n                    status = \"failed\";\n                }\n\n                // Are there an attachment for this step?\n                if (\"embeddings\" in step) {\n                    console.log(\"Has attachment\");\n\n                    attCount = 0;\n                    step.embeddings.forEach(function (att) {\n                        attCount++;\n                        var attachment = {\n                            name: step.name + \" Attachment \" + attCount,\n                            \"content_type\": att.mime_type,\n                            data: att.data\n                        };\n                        console.log(\"Attachment: \" + attachment.name)\n\n                        attachments.push(attachment);\n                    });\n                }\n\n                var expected = step.keyword + \" \" + step.name;\n\n                if (\"location\" in step.match) {\n                    expected = step.match.location;\n                }\n\n                var stepLog = {\n                    order: order,\n                    description: step.name,\n                    expected_result: step.keyword,\n                    actual_result: actual,\n                    status: status\n                };\n\n                testStepLogs.push(stepLog);\n                order++;\n            });\n\n            reportingLog.attachments = attachments;\n            reportingLog.description = stepNames.join(\"<br/>\");\n            reportingLog.status = TCStatus;\n            reportingLog.test_step_logs = testStepLogs;\n            reportingLog.featureName = featureName;\n            testLogs.push(reportingLog);\n        });\n    });\n\n    var formattedResults = {\n        \"projectId\": projectId,\n        \"test-cycle\": cycleId,\n        \"logs\": testLogs\n    };\n\n\n    // Pulse Version\n    // Emit next fxn to upload results/parse\n    emitEvent('UpdateQTestWithFormattedResultsEvent', formattedResults);\n\n    /// Command line version\n    // Write new file\n    //var payload = fs.writeFile('formattedResults.json', JSON.stringify(formattedResults, null, \"  \" ), 'utf8', function() {\n    //    console.log(\"File written: formattedResults.json\");\n    //});\n}\n"
    },
    {
      "id": "action-2",
      "name": "FormatPythonPyTestJUnit",
      "description": null,
      "code": "const { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    /////// Pulse version\n    var payload = body;\n    var testResults = payload.result;\n    var projectId = payload.projectId;\n    var cycleId = payload[\"test-cycle\"];\n\n    xml2js = require('xml2js');\n\n    //////// Commandline version\n    // var fs = require('fs');\n    //\n    // var projectId = 12345;\n    // var cycleId = 12341234;\n    /// TODO: Remove above\n\n    var testLogs = [];\n    function FormatLogs(tr) {\n\n        var testResults = JSON.parse(tr);\n        testResults.testsuite.testcase.forEach(function (tc) {\n            var tcResult = tc[\"$\"];\n            var tcName = \"\";\n\n            // Format the name\n            var note = \"\";\n            if (!tcResult.name)\n                tcName = \"Unnamed\";\n            else\n                tcName = tcResult.name.substring(0, tcResult.name.indexOf('['));\n            note = tcResult.name;\n\n            TCStatus = \"PASS\";\n\n            if (tc.failure) {\n                TCStatus = \"FAIL\";\n                if (note)\n                    note = \"\\n\" + JSON.stringify(tc.failure);\n                else\n                    note = JSON.stringify(tc.failure);\n            }\n\n            // The automation content is what we're going to use to run this later so it's important to get that format for Python pytest\n            //$file :: $classname (after the last .) :: $name (before the [)\n            var tcShortClassName = tcResult.classname.substring(tcResult.classname.lastIndexOf('.') + 1)\n            var auto = tcResult.file + \"::\" + tcShortClassName + \"::\" + tcName;\n\n            var reportingLog = {\n                exe_start_date: new Date(), // TODO this could use the time to complete to be more precise\n                exe_end_date: new Date(),\n                module_names: [\n                    'JUnitTests'\n                ],\n                name: tcName,\n                automation_content: auto,\n                note: note\n            };\n\n            // There are no steps here, so we'll add one step entry\n            var testStepLogs = [{\n                order: 0,\n                description: tcName,\n                expected_result: tcName,\n                status: TCStatus\n            }];\n\n            reportingLog.description = \"Test case imported from Python Test\"\n            reportingLog.status = TCStatus;\n            reportingLog.test_step_logs = testStepLogs;\n            testLogs.push(reportingLog);\n        });\n\n        var formattedResults = {\n            \"projectId\": projectId,\n            \"test-cycle\": cycleId,\n            \"logs\": testLogs\n        };\n\n        return formattedResults;\n    }\n\n    // Pulse Version\n    var parser = new xml2js.Parser();\n    parser.parseString(testResults, function (err, result) {\n        var formattedResults = FormatLogs(JSON.stringify(result));\n        emitEvent('$YOUR_UPLOAD_TO_QTEST_EVENT_URL', formattedResults);\n    });\n\n    /// Command line version\n    // fs.readFile('results.xml', function(err, data) {\n    //     parser.parseString(data, function (err, result) {\n    //         var formattedResults = FormatLogs(JSON.stringify(result));\n    //         Write new file\n    //         var payload = fs.writeFile('formattedResults.json', JSON.stringify(formattedResults, null, \"  \" ), 'utf8', function() {\n    //             console.log(\"File written: formattedResults.json\");\n    //         });\n    //     });\n    // });\n}\n"
    },
    {
      "id": "action-3",
      "name": "FormatPostmanJson",
      "description": null,
      "code": "const { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    // Payload to be passed in: json style cucumber for java test results\n\n    /////// Pulse version\n    var payload = body;\n    var testResults = payload.result;\n    var projectId = payload.projectId;\n    var cycleId = payload[\"test-cycle\"];\n\n    var collectionName = testResults.collection.info.name;\n    var testLogs = [];\n\n    testResults.run.executions.forEach(function (testCase) {\n\n        var featureName = testCase.item.name;\n\n        TCStatus = \"passed\";\n        var reportingLog = {\n            exe_start_date: new Date(), // TODO These could be passed in\n            exe_end_date: new Date(),\n            module_names: [\n                'Postman'\n            ],\n            name: testCase.item.name,\n            automation_content: collectionName + \"#\" + testCase.item.name // TODO See if ID is static or when that changes\n        };\n\n        var testStepLogs = [];\n        order = 0;\n        stepNames = [];\n\n        if (!(\"assertions\" in testCase)) {\n            return;\n        }\n\n        testCase.assertions.forEach(function (step) {\n            stepNames.push(step.assertion);\n            stepErrorVal = \"passed\";\n\n            var actual = step.assertion;\n\n            if (\"error\" in step) {\n                stepErrorVal = \"failed\";\n                TCStatus = \"failed\";\n                actual = step.error.message;\n            }\n\n            var stepLog = {\n                order: order,\n                description: step.assertion,\n                expected_result: step.assertion,\n                status: stepErrorVal,\n                actual_result: actual\n            };\n\n            testStepLogs.push(stepLog);\n            order++;\n        });\n\n        reportingLog.description = \"Created by Pulse\"; // testCase.request;\n        reportingLog.status = TCStatus;\n        reportingLog.test_step_logs = testStepLogs;\n        reportingLog.featureName = featureName;\n        testLogs.push(reportingLog);\n\n    });\n\n    var formattedResults = {\n        \"projectId\": projectId,\n        \"test-cycle\": cycleId,\n        \"logs\": testLogs\n    };\n\n\n    // Pulse Version\n    emitEvent('$YOUR_UPLOAD_TO_QTEST_EVENT_URL', formattedResults);\n}\n"
    },
    {
      "id": "action-4",
      "name": "LinkScenarioRequirements",
      "description": null,
      "code": "const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\nconst ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconsole.log(\"Starting Link Requirements Action\");\n    \nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    \n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n    // Specific to pulse actions\n    var payload = body;\n\n    var testLogs = payload.logs;\n    var projectId = payload.projectId;\n\n    var standardHeaders = {\n        'Content-Type': 'application/json',\n        'Authorization': `bearer ${constants.QTEST_TOKEN}`,\n        'x-scenario-project-id': constants.SCENARIO_PROJECT_ID\n    }\n\n    const options = {\n        url: constants.Scenario_URL + 'features',\n        method: 'GET',\n        headers: standardHeaders\n    };\n\n    var features;\n    console.log(\"Getting feature list options: \" + options);\n    request.get(options, function (optserr, optsresponse, resbody) {\n        if (optserr) {\n            console.log(\"Problem Getting Feature List: \" + optserr);\n        }\n        else {\n            console.log(\"Got Features List: \" + resbody);\n            features = JSON.parse(resbody);\n            LinkRequirements();\n        }\n    });\n    \n    // This makes a best effort to link if test cases exist. Not if you just uploaded via the auto-test-logs endpoint, the job is batched and may not be completed yet\n    function LinkRequirements() {\n        testLogs.forEach(function (testcase) {\n        \n        var matchingFeature = features.find(x => x.name === testcase.featureName);\n\n        if(!matchingFeature)\n            return;\n            \n        var reqopts = getReqBody(matchingFeature.issueKey);\n        request.post(reqopts, function (err, response, featureResBody) {\n\n            if (err) {\n                emitEvent('SlackEvent', { Error: \"Problem getting requirement: \" + err });\n            }\n            else {\n                if (featureResBody.items.length === 0) // No corresponding feature exists in scenario\n                    return;\n\n                var reqid = featureResBody.items[0].id;\n                var tcopts = getTCBody(testcase.name);\n\n                request.post(tcopts, function (tcerr, tcresponse, testCaseResBody) {\n\n                    if (tcerr) {\n                        emitEvent('SlackEvent', { Error: \"Problem getting test case: \" + err });\n                    }\n                    else {\n                        if(testCaseResBody.items.length === 0) // Test Case Doesn't yet exist - we'll try this another time\n                            return;\n\n                        var tcid = testCaseResBody.items[0].id;\n                        var linkopts = getLinkBody(reqid, tcid);\n\n                        request.post(linkopts, function (optserr, optsresponse, resbody) {\n                            if (optserr) {\n                                emitEvent('SlackEvent', { Error: \"Problem creating test link to requirement: \" + err });\n                            }\n                            else {\n                                // Success, we added a link!\n                                emitEvent('SlackEvent', { Linking: \"link added for TC: \" + testcase.name + \" to requirement \" + matchingFeature.issueKey });\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    });\n\n    }\n\n    function getTCBody(TCName) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/search\",\n            json: true,\n            headers: standardHeaders,\n            body: {\n                \"object_type\": \"test-cases\",\n                \"fields\": [\n                    \"*\"\n                ],\n                \"query\": \"Name = '\" + TCName + \"'\"\n            }\n        };\n    }\n\n    function getReqBody(key) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/search\",\n            json: true,\n            headers: standardHeaders,\n            body: {\n                \"object_type\": \"requirements\",\n                \"fields\": [\n                    \"*\"\n                ],\n                \"query\": \"Name ~ '\" + key + \"'\"\n            }\n        };\n    }\n\n    function getLinkBody(reqid, tcid) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/requirements/\" + reqid + \"/link?type=test-cases\",\n            json: true,\n            headers: standardHeaders,\n            body: [\n                tcid\n            ]\n        };\n    }\n}\n"
    },
    {
      "id": "action-5",
      "name": "triggerJenkins",
      "description": null,
      "code": "const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    var url = \"http://\" + constants.JenkinsUserName + \":\" + constants.JenkinsAPIToken + \"@\" +\n        constants.JenkinsURL + '/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,\":\",//crumb)';\n\n    request.get({ url: url, insecure: true }, function (err, response, body) {\n        if (!err) {\n            var crumb = body.split(\":\")[1];\n\n            var joburl = \"http://\" + constants.JenkinsUserName + \":\" + constants.JenkinsAPIToken + \"@\" +\n                constants.JenkinsURL + \"/job/\" + constants.JenkinsJobName + \"/build?token=\" + constants.JenkinsJobToken\n            var opts = {\n                url: joburl,\n                insecure: true,\n                contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n                headers: {\n                    \"Jenkins-Crumb\": crumb\n                }\n            }\n\n            request.post(opts, function (err, res, bd) {\n                emitEvent('SlackEvent', { JenkinsCallSuccess: \"Jenkins Build just kicked off for project \" + constants.JenkinsJobName });\n            })\n        }\n    })\n}\n"
    },
    {
      "id": "action-6",
      "name": "UpdateQTestWithFormattedResults",
      "description": null,
      "code": "const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\nconst ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconst Features = {\n    getIssueLinkByFeatureName(qtestToken, scenarioProjectId, name) {\n        return new ScenarioSdk.Features({ qtestToken, scenarioProjectId }).getFeatures(`\"${name}\"`);\n    }\n};\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    // Specific to pulse actions\n    var payload = body;\n\n    var testLogs = payload.logs;\n    var cycleId = payload[\"test-cycle\"];\n    var projectId = payload.projectId;\n\n    var scenarioCount = 0;\n    var scenarioList = \"\";\n\n    var standardHearders = {\n        'Content-Type': 'application/json',\n        'Authorization': `bearer ${constants.QTEST_TOKEN}`\n    }\n\n    var createLogsAndTCs = function () {\n        var opts = {\n            url: \"http://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/auto-test-logs?type=automation\",\n            json: true,\n            headers: standardHearders,\n            body: {\n                test_cycle: cycleId,\n                test_logs: testLogs\n            }\n        };\n\n        return request.post(opts, function (err, response, resbody) {\n\n            if (err) {\n                Promise.reject(err);\n            }\n            else {\n                emitEvent('SlackEvent', { AutomationLogUploaded: resbody });\n\n                if (response.body.type == \"AUTOMATION_TEST_LOG\") {\n                    Promise.resolve(\"Uploaded results successfully\");\n                }\n                else {\n                    emitEvent('SlackEvent', { Error: \"Wrong type\" });\n                    Promise.reject(\"Unable to upload test results\");\n                }\n            }\n        });\n    };\n\n    createLogsAndTCs()\n        .on('response', function () {\n            console.log(\"About to call Link Requirements Rule\")\n            emitEvent('LinkScenarioRequirements', payload);\n            //linkReq();\n        })\n        .on('error', function (err) {\n            emitEvent('SlackEvent', { CaughtError: err });\n        })\n}"
    },
    {
      "id": "action-7",
      "name": "SlackAction",
      "description": null,
      "code": "exports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    var str = body;\n\n    var request = require('request');\n    var slack_webhook = constants.SlackWebHook;\n\n    console.log('About to request slack webhook: ', slack_webhook);\n\n    request({\n        uri: slack_webhook,\n        method: 'POST',\n        json: { \"text\": JSON.stringify(str) }\n    }, function (error, response, body) { }\n    );\n}\n"
    },
    {
      "id": "action-8",
      "name": "scenarioColors",
      "description": null,
      "code": "const ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconst StepSdk = {\n    getStepSdk(qtestToken, scenarioProjectId) {\n        return new ScenarioSdk.Steps({ qtestToken, scenarioProjectId });\n    }\n}\n\nconst Steps = {\n    updateStepResults(stepSdk, name, status) {\n        return stepSdk.getSteps(`\"${name}\"`).\n            then(steps => Promise.all(steps.map(step => stepSdk.updateStep(step.id, Object.assign(step, { status })))))\n            .catch(function (err) {\n                console.log(\"Name: \" + name + \" : STATUS:  \" + status);\n                console.log('Error updating colors: ' + err);\n            });\n    }\n};\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    var payload = body;\n    var testLogs = payload.logs;\n\n    stepSdk = StepSdk.getStepSdk(constants.QTEST_TOKEN, constants.SCENARIO_PROJECT_ID);\n    \n    for (var res of testLogs) {\n        for (var step of res[\"test_step_logs\"]) {\n            var stepName = step.description;\n            var stepStatus = step.status;\n\n            // Undefined means no step definition existed and it should fail\n            if (stepStatus == \"undefined\") {\n                stepStatus = \"failed\";\n            }\n\n            // one of PASSED (green), FAILED (red), or SKIPPED (yellow)\n            stepStatus = stepStatus.toUpperCase();\n\n            // Call the pulse API to update step results\n            Steps.updateStepResults(stepSdk, stepName, stepStatus);\n        }\n    }\n}\n"
    },
    {
      "id": "action-9",
      "name": "CreateTestCase",
      "description": "Action to Create A Test Case - expecting standard Jira Webhook Payload",
      "code": "const { Webhooks } = require('@qasymphony/pulse-sdk');\nconst request = require('request');\nconst xml2js = require('xml2js');\n\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n  let str = body;\n\n  let standardHeaders = {\n    'Content-Type': 'application/json',\n    'Authorization': `bearer ${constants.QTEST_TOKEN}`\n  }\n\n  function emitEvent(name, payload) {\n      let t = triggers.find(t => t.name === name);\n      return t && new Webhooks().invoke(t, payload);\n  }\n\n  // Get Issue Key from Jira Webhook content\n  let issueID = str.issue.key;\n  console.log(\"Newly created Jira Requirement: \" + issueID)\n\n  let tcid = \"\";\n  // Create a Test Case in qTest\n  request({\n        uri: `https://${constants.ManagerURL}/api/v3/projects/${constants.ProjectID}/test-cases`,\n        method: 'POST',\n        headers: standardHeaders,\n        json: {\n          \"name\": \"TC for Req \" + issueID\n        }\n    }, function (error, response, body) {\n      if(error)\n        console.log(`ERROR: ${error}`);\n      else\n        console.log(response);\n\n        emitEvent('SlackEvent', { NewTestCase: \"A new test case was added here: \" + response.body.web_url });\n\n        // Get the Test Case Object ID\n        tcid = response.body.id;\n        console.log(`New TCID: ${tcid} located at ${response.body.web_url}`);\n\n        emitEvent('LinkRequirement', { \"tcid\": tcid, \"issueKey\": issueID });\n    }\n  );\n}"
    },
    {
      "id": "action-10",
      "name": "LinkRequirement",
      "description": "Action to set up a link between a Jira Requirement already linked to qTest to a Test Case via the Jira Issue Key and the qTest Test Case Object ID",
      "code": "const { Webhooks } = require('@qasymphony/pulse-sdk');\nconst request = require('request');\nconst xml2js = require('xml2js');\n\n//\n// Expects the payload to look like this\n// {\n//   tcid: 12345,\n//   issueKey: 'AI-123'\n// }\n//\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n  function emitEvent(name, payload) {\n      let t = triggers.find(t => t.name === name);\n      return t && new Webhooks().invoke(t, payload);\n  }\n\n  var standardHeaders = {\n    'Content-Type': 'application/json',\n    'Authorization': `bearer ${constants.QTEST_TOKEN}`\n  }\n\n  var reqopts = getReqBody(body.issueKey);\n  request.post(reqopts, function (err, response, reqResBody) {\n\n      if (err) {\n          emitEvent('SlackEvent', { Error: \"Problem getting requirement: \" + err });\n      }\n      else {\n          if (reqResBody.items.length === 0)\n              return;\n\n          var reqid = reqResBody.items[0].id;\n            var linkopts = getLinkBody(reqid, body.tcid);\n\n            request.post(linkopts, function (optserr, optsresponse, resbody) {\n                if (optserr) {\n                    emitEvent('SlackEvent', { Error: \"Problem creating test link to requirement: \" + err });\n                }\n                else {\n                    // Success, we added a link!\n                    emitEvent('SlackEvent', { Linking: \"link added for TC: \" + body.tcid + \" to requirement \" + body.issueKey });\n                }\n            });\n      }\n  });\n\n  function getReqBody(key) {\n    return {\n        url: `https://${constants.ManagerURL}/api/v3/projects/${constants.ProjectID}/search`,\n        json: true,\n        headers: standardHeaders,\n        body: {\n            \"object_type\": \"requirements\",\n            \"fields\": [\n                \"*\"\n            ],\n            \"query\": \"Name ~ '\" + key + \"'\"\n        }\n    };\n  }\n\n  function getLinkBody(reqid, tcid) {\n    return {\n        url: `https://${constants.ManagerURL}/api/v3/projects/${constants.ProjectID}/requirements/${reqid}/link?type=test-cases`,\n        json: true,\n        headers: standardHeaders,\n        body: [\n            tcid\n        ]\n    };\n  }\n}\n\n"
    }
  ],
  "triggers": [
    {
      "id": "trigger-1",
      "name": "SlackEvent"
    },
    {
      "id": "trigger-2",
      "name": "triggerJenkins"
    },
    {
      "id": "trigger-3",
      "name": "LinkScenarioRequirements"
    },
    {
      "id": "trigger-4",
      "name": "UploadPythonJUnitResults"
    },
    {
      "id": "trigger-5",
      "name": "scenarioColors"
    },
    {
      "id": "trigger-6",
      "name": "UploadJavaCucumberResults"
    },
    {
      "id": "trigger-7",
      "name": "UpdateQTestWithFormattedResultsEvent"
    },
    {
      "id": "trigger-8",
      "name": "CreateTestCase"
    },
    {
      "id": "trigger-9",
      "name": "LinkRequirement"
    }
  ],
  "rules": [
    {
      "id": "rule-10",
      "name": "triggerJenkins",
      "active": true,
      "triggerId": "trigger-2",
      "actionIds": [
        "action-5"
      ],
      "tags": []
    },
    {
      "id": "rule-11",
      "name": "ParseAndUploadPostmanJsonTestResults",
      "active": true,
      "triggerId": "trigger-1",
      "actionIds": [
        "action-3"
      ],
      "tags": []
    },
    {
      "id": "rule-12",
      "name": "MessageSlack",
      "active": true,
      "triggerId": "trigger-1",
      "actionIds": [
        "action-7"
      ],
      "tags": []
    },
    {
      "id": "rule-13",
      "name": "LinkTestCasesToRequirementsWithScenario",
      "active": true,
      "triggerId": "trigger-3",
      "actionIds": [
        "action-4"
      ],
      "tags": []
    },
    {
      "id": "rule-14",
      "name": "UploadJavaCucumberResultsWithScenario",
      "active": true,
      "triggerId": "trigger-7",
      "actionIds": [
        "action-8",
        "action-6"
      ],
      "tags": []
    },
    {
      "id": "rule-15",
      "name": "UploadJavaCucumberResults",
      "active": true,
      "triggerId": "trigger-6",
      "actionIds": [
        "action-1"
      ],
      "tags": []
    },
    {
      "id": "rule-16",
      "name": "ParseAndUploadPythonPyTestResults",
      "active": true,
      "triggerId": "trigger-4",
      "actionIds": [
        "action-2"
      ],
      "tags": []
    },
    {
      "id": "rule-17",
      "name": "LinkRequirement",
      "active": true,
      "triggerId": "trigger-9",
      "actionIds": [
        "action-10"
      ],
      "tags": []
    },
    {
      "id": "rule-18",
      "name": "CreateTestCase",
      "active": true,
      "triggerId": "trigger-8",
      "actionIds": [
        "action-9"
      ],
      "tags": []
    }
  ]
}
