{"constants":[{"id":"constant-1","name":"SlackWebHook","hidden":false,"value":""},{"id":"constant-2","name":"QTEST_TOKEN","hidden":false,"value":""},{"id":"constant-3","name":"SlackWebHook","hidden":false,"value":""},{"id":"constant-4","name":"ManagerURL","hidden":false,"value":""},{"id":"constant-5","name":"SCENARIO_PROJECT_ID","hidden":false,"value":""},{"id":"constant-6","name":"JenkinsURL","hidden":false,"value":""},{"id":"constant-7","name":"JenkinsJobName","hidden":false,"value":""},{"id":"constant-8","name":"JenkinsAPIToken","hidden":false,"value":""},{"id":"constant-9","name":"JenkinsJobToken","hidden":false,"value":""},{"id":"constant-10","name":"JenkinsUserName","hidden":false,"value":""},{"id":"constant-11","name":"Scenario_URL","hidden":false,"value":""}],"actions":[{"id":"action-1","name":"FormatJavaCucumber","description":null,"code":"const { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    // Payload to be passed in: json style cucumber for java test results\n\n    /////// Pulse version\n    var payload = body;\n    var testResults = payload.result;\n    var projectId = payload.projectId;\n    var cycleId = payload[\"test-cycle\"];\n\n    var testLogs = [];\n    console.log(\"TEST RESULTS: \" + testResults);\n\n    //emitEvent('SlackEvent', { TESTRESULTS: testResults });\n\n    testResults.forEach(function (feature) {\n        var featureName = feature.name;\n        feature.elements.forEach(function (testCase) {\n\n            if (!testCase.name)\n                testCase.name = \"Unnamed\";\n\n            TCStatus = \"passed\";\n\n            var reportingLog = {\n                exe_start_date: new Date(), // TODO These could be passed in\n                exe_end_date: new Date(),\n                module_names: [\n                    'Test Scenarios'\n                ],\n                name: testCase.name,\n                automation_content: feature.uri + \"#\" + testCase.name\n            };\n\n            var testStepLogs = [];\n            order = 0;\n            stepNames = [];\n            attachments = [];\n\n            testCase.steps.forEach(function (step) {\n                stepNames.push(step.name);\n\n                var status = step.result.status;\n                var actual = step.name;\n\n                if (TCStatus == \"passed\" && status == \"skipped\") {\n                    TCStatus = \"skipped\";\n                }\n                if (status == \"failed\") {\n                    TCStatus = \"failed\";\n                    actual = step.result.error_message;\n                }\n                if (status == \"undefined\") {\n                    TCStatus = \"failed\";\n                    status = \"failed\";\n                }\n\n                // Are there an attachment for this step?\n                if (\"embeddings\" in step) {\n                    console.log(\"Has attachment\");\n\n                    attCount = 0;\n                    step.embeddings.forEach(function (att) {\n                        attCount++;\n                        var attachment = {\n                            name: step.name + \" Attachment \" + attCount,\n                            \"content_type\": att.mime_type,\n                            data: att.data\n                        };\n                        console.log(\"Attachment: \" + attachment.name)\n\n                        attachments.push(attachment);\n                    });\n                }\n\n                var expected = step.keyword + \" \" + step.name;\n\n                if (\"location\" in step.match) {\n                    expected = step.match.location;\n                }\n\n                var stepLog = {\n                    order: order,\n                    description: step.name,\n                    expected_result: step.keyword,\n                    actual_result: actual,\n                    status: status\n                };\n\n                testStepLogs.push(stepLog);\n                order++;\n            });\n\n            reportingLog.attachments = attachments;\n            reportingLog.description = stepNames.join(\"<br/>\");\n            reportingLog.status = TCStatus;\n            reportingLog.test_step_logs = testStepLogs;\n            reportingLog.featureName = featureName;\n            testLogs.push(reportingLog);\n        });\n    });\n\n    var formattedResults = {\n        \"projectId\": projectId,\n        \"test-cycle\": cycleId,\n        \"logs\": testLogs\n    };\n\n\n    // Pulse Version\n    // Emit next fxn to upload results/parse\n    emitEvent('UpdateQTestWithFormattedResultsEvent', formattedResults);\n\n    /// Command line version\n    // Write new file\n    //var payload = fs.writeFile('formattedResults.json', JSON.stringify(formattedResults, null, \"  \" ), 'utf8', function() {\n    //    console.log(\"File written: formattedResults.json\");\n    //});\n}\n"},{"id":"action-2","name":"FormatPythonPyTestJUnit","description":null,"code":"const { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    /////// Pulse version\n    var payload = body;\n    var testResults = payload.result;\n    var projectId = payload.projectId;\n    var cycleId = payload[\"test-cycle\"];\n\n    xml2js = require('xml2js');\n\n    //////// Commandline version\n    // var fs = require('fs');\n    //\n    // var projectId = 12345;\n    // var cycleId = 12341234;\n    /// TODO: Remove above\n\n    var testLogs = [];\n    function FormatLogs(tr) {\n\n        var testResults = JSON.parse(tr);\n        testResults.testsuite.testcase.forEach(function (tc) {\n            var tcResult = tc[\"$\"];\n            var tcName = \"\";\n\n            // Format the name\n            var note = \"\";\n            if (!tcResult.name)\n                tcName = \"Unnamed\";\n            else\n                tcName = tcResult.name.substring(0, tcResult.name.indexOf('['));\n            note = tcResult.name;\n\n            TCStatus = \"PASS\";\n\n            if (tc.failure) {\n                TCStatus = \"FAIL\";\n                if (note)\n                    note = \"\\n\" + JSON.stringify(tc.failure);\n                else\n                    note = JSON.stringify(tc.failure);\n            }\n\n            // The automation content is what we're going to use to run this later so it's important to get that format for Python pytest\n            //$file :: $classname (after the last .) :: $name (before the [)\n            var tcShortClassName = tcResult.classname.substring(tcResult.classname.lastIndexOf('.') + 1)\n            var auto = tcResult.file + \"::\" + tcShortClassName + \"::\" + tcName;\n\n            var reportingLog = {\n                exe_start_date: new Date(), // TODO this could use the time to complete to be more precise\n                exe_end_date: new Date(),\n                module_names: [\n                    'JUnitTests'\n                ],\n                name: tcName,\n                automation_content: auto,\n                note: note\n            };\n\n            // There are no steps here, so we'll add one step entry\n            var testStepLogs = [{\n                order: 0,\n                description: tcName,\n                expected_result: tcName,\n                status: TCStatus\n            }];\n\n            reportingLog.description = \"Test case imported from Python Test\"\n            reportingLog.status = TCStatus;\n            reportingLog.test_step_logs = testStepLogs;\n            testLogs.push(reportingLog);\n        });\n\n        var formattedResults = {\n            \"projectId\": projectId,\n            \"test-cycle\": cycleId,\n            \"logs\": testLogs\n        };\n\n        return formattedResults;\n    }\n\n    // Pulse Version\n    var parser = new xml2js.Parser();\n    parser.parseString(testResults, function (err, result) {\n        var formattedResults = FormatLogs(JSON.stringify(result));\n        emitEvent('$YOUR_UPLOAD_TO_QTEST_EVENT_URL', formattedResults);\n    });\n\n    /// Command line version\n    // fs.readFile('results.xml', function(err, data) {\n    //     parser.parseString(data, function (err, result) {\n    //         var formattedResults = FormatLogs(JSON.stringify(result));\n    //         Write new file\n    //         var payload = fs.writeFile('formattedResults.json', JSON.stringify(formattedResults, null, \"  \" ), 'utf8', function() {\n    //             console.log(\"File written: formattedResults.json\");\n    //         });\n    //     });\n    // });\n}\n"},{"id":"action-3","name":"FormatPostmanJson","description":null,"code":"const { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    // Payload to be passed in: json style cucumber for java test results\n\n    /////// Pulse version\n    var payload = body;\n    var testResults = payload.result;\n    var projectId = payload.projectId;\n    var cycleId = payload[\"test-cycle\"];\n\n    var collectionName = testResults.collection.info.name;\n    var testLogs = [];\n\n    testResults.run.executions.forEach(function (testCase) {\n\n        var featureName = testCase.item.name;\n\n        TCStatus = \"passed\";\n        var reportingLog = {\n            exe_start_date: new Date(), // TODO These could be passed in\n            exe_end_date: new Date(),\n            module_names: [\n                'Postman'\n            ],\n            name: testCase.item.name,\n            automation_content: collectionName + \"#\" + testCase.item.name // TODO See if ID is static or when that changes\n        };\n\n        var testStepLogs = [];\n        order = 0;\n        stepNames = [];\n\n        if (!(\"assertions\" in testCase)) {\n            return;\n        }\n\n        testCase.assertions.forEach(function (step) {\n            stepNames.push(step.assertion);\n            stepErrorVal = \"passed\";\n\n            var actual = step.assertion;\n\n            if (\"error\" in step) {\n                stepErrorVal = \"failed\";\n                TCStatus = \"failed\";\n                actual = step.error.message;\n            }\n\n            var stepLog = {\n                order: order,\n                description: step.assertion,\n                expected_result: step.assertion,\n                status: stepErrorVal,\n                actual_result: actual\n            };\n\n            testStepLogs.push(stepLog);\n            order++;\n        });\n\n        reportingLog.description = \"Created by Pulse\"; // testCase.request;\n        reportingLog.status = TCStatus;\n        reportingLog.test_step_logs = testStepLogs;\n        reportingLog.featureName = featureName;\n        testLogs.push(reportingLog);\n\n    });\n\n    var formattedResults = {\n        \"projectId\": projectId,\n        \"test-cycle\": cycleId,\n        \"logs\": testLogs\n    };\n\n\n    // Pulse Version\n    emitEvent('$YOUR_UPLOAD_TO_QTEST_EVENT_URL', formattedResults);\n}\n"},{"id":"action-4","name":"LinkScenarioRequirements","description":null,"code":"const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\nconst ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconsole.log(\"Starting Link Requirements Action\");\n    \nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    \n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n    // Specific to pulse actions\n    var payload = body;\n\n    var testLogs = payload.logs;\n    var projectId = payload.projectId;\n\n    var standardHeaders = {\n        'Content-Type': 'application/json',\n        'Authorization': `bearer ${constants.QTEST_TOKEN}`,\n        'x-scenario-project-id': constants.SCENARIO_PROJECT_ID\n    }\n\n    const options = {\n        url: constants.Scenario_URL + 'features',\n        method: 'GET',\n        headers: standardHeaders\n    };\n\n    var features;\n    console.log(\"Getting feature list options: \" + options);\n    request.get(options, function (optserr, optsresponse, resbody) {\n        if (optserr) {\n            console.log(\"Problem Getting Feature List: \" + optserr);\n        }\n        else {\n            console.log(\"Got Features List: \" + resbody);\n            features = JSON.parse(resbody);\n            LinkRequirements();\n        }\n    });\n    \n    // This makes a best effort to link if test cases exist. Not if you just uploaded via the auto-test-logs endpoint, the job is batched and may not be completed yet\n    function LinkRequirements() {\n        testLogs.forEach(function (testcase) {\n        \n        var matchingFeature = features.find(x => x.name === testcase.featureName);\n\n        if(!matchingFeature)\n            return;\n            \n        var reqopts = getReqBody(matchingFeature.issueKey);\n        request.post(reqopts, function (err, response, featureResBody) {\n\n            if (err) {\n                emitEvent('SlackEvent', { Error: \"Problem getting requirement: \" + err });\n            }\n            else {\n                if (featureResBody.items.length === 0) // No corresponding feature exists in scenario\n                    return;\n\n                var reqid = featureResBody.items[0].id;\n                var tcopts = getTCBody(testcase.name);\n\n                request.post(tcopts, function (tcerr, tcresponse, testCaseResBody) {\n\n                    if (tcerr) {\n                        emitEvent('SlackEvent', { Error: \"Problem getting test case: \" + err });\n                    }\n                    else {\n                        if(testCaseResBody.items.length === 0) // Test Case Doesn't yet exist - we'll try this another time\n                            return;\n\n                        var tcid = testCaseResBody.items[0].id;\n                        var linkopts = getLinkBody(reqid, tcid);\n\n                        request.post(linkopts, function (optserr, optsresponse, resbody) {\n                            if (optserr) {\n                                emitEvent('SlackEvent', { Error: \"Problem creating test link to requirement: \" + err });\n                            }\n                            else {\n                                // Success, we added a link!\n                                emitEvent('SlackEvent', { Linking: \"link added for TC: \" + testcase.name + \" to requirement \" + matchingFeature.issueKey });\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    });\n\n    }\n\n    function getTCBody(TCName) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/search\",\n            json: true,\n            headers: standardHeaders,\n            body: {\n                \"object_type\": \"test-cases\",\n                \"fields\": [\n                    \"*\"\n                ],\n                \"query\": \"Name = '\" + TCName + \"'\"\n            }\n        };\n    }\n\n    function getReqBody(key) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/search\",\n            json: true,\n            headers: standardHeaders,\n            body: {\n                \"object_type\": \"requirements\",\n                \"fields\": [\n                    \"*\"\n                ],\n                \"query\": \"Name ~ '\" + key + \"'\"\n            }\n        };\n    }\n\n    function getLinkBody(reqid, tcid) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/requirements/\" + reqid + \"/link?type=test-cases\",\n            json: true,\n            headers: standardHeaders,\n            body: [\n                tcid\n            ]\n        };\n    }\n}\n"},{"id":"action-5","name":"scenarioColors","description":null,"code":"const ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconst StepSdk = {\n    getStepSdk(qtestToken, scenarioProjectId) {\n        return new ScenarioSdk.Steps({ qtestToken, scenarioProjectId });\n    }\n}\n\nconst Steps = {\n    updateStepResults(stepSdk, name, status) {\n        return stepSdk.getSteps(`\"${name}\"`).\n            then(steps => Promise.all(steps.map(step => stepSdk.updateStep(step.id, Object.assign(step, { status })))))\n            .catch(function (err) {\n                console.log(\"Name: \" + name + \" : STATUS:  \" + status);\n                console.log('Error updating colors: ' + err);\n            });\n    }\n};\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    var payload = body;\n    var testLogs = payload.logs;\n\n    stepSdk = StepSdk.getStepSdk(constants.QTEST_TOKEN, constants.SCENARIO_PROJECT_ID);\n    \n    for (var res of testLogs) {\n        for (var step of res[\"test_step_logs\"]) {\n            var stepName = step.description;\n            var stepStatus = step.status;\n\n            // Undefined means no step definition existed and it should fail\n            if (stepStatus == \"undefined\") {\n                stepStatus = \"failed\";\n            }\n\n            // one of PASSED (green), FAILED (red), or SKIPPED (yellow)\n            stepStatus = stepStatus.toUpperCase();\n\n            // Call the pulse API to update step results\n            Steps.updateStepResults(stepSdk, stepName, stepStatus);\n        }\n    }\n}\n"},{"id":"action-6","name":"triggerJenkins","description":null,"code":"const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    var url = \"http://\" + constants.JenkinsUserName + \":\" + constants.JenkinsAPIToken + \"@\" +\n        constants.JenkinsURL + '/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,\":\",//crumb)';\n\n    request.get({ url: url, insecure: true }, function (err, response, body) {\n        if (!err) {\n            var crumb = body.split(\":\")[1];\n\n            var joburl = \"http://\" + constants.JenkinsUserName + \":\" + constants.JenkinsAPIToken + \"@\" +\n                constants.JenkinsURL + \"/job/\" + constants.JenkinsJobName + \"/build?token=\" + constants.JenkinsJobToken\n            var opts = {\n                url: joburl,\n                insecure: true,\n                contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n                headers: {\n                    \"Jenkins-Crumb\": crumb\n                }\n            }\n\n            request.post(opts, function (err, res, bd) {\n                emitEvent('SlackEvent', { JenkinsCallSuccess: \"Jenkins Build just kicked off for project \" + constants.JenkinsJobName });\n            })\n        }\n    })\n}\n"},{"id":"action-7","name":"SlackAction","description":null,"code":"exports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    var str = body;\n\n    var request = require('request');\n    var slack_webhook = constants.SlackWebHook;\n\n    console.log('About to request slack webhook: ', slack_webhook);\n\n    request({\n        uri: slack_webhook,\n        method: 'POST',\n        json: { \"text\": JSON.stringify(str) }\n    }, function (error, response, body) { }\n    );\n}\n"},{"id":"action-8","name":"UpdateQTestWithFormattedResults","description":null,"code":"const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\nconst ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconst Features = {\n    getIssueLinkByFeatureName(qtestToken, scenarioProjectId, name) {\n        return new ScenarioSdk.Features({ qtestToken, scenarioProjectId }).getFeatures(`\"${name}\"`);\n    }\n};\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    // Specific to pulse actions\n    var payload = body;\n\n    var testLogs = payload.logs;\n    var cycleId = payload[\"test-cycle\"];\n    var projectId = payload.projectId;\n\n    var scenarioCount = 0;\n    var scenarioList = \"\";\n\n    var standardHearders = {\n        'Content-Type': 'application/json',\n        'Authorization': `bearer ${constants.QTEST_TOKEN}`\n    }\n\n    var createLogsAndTCs = function () {\n        var opts = {\n            url: \"http://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/auto-test-logs?type=automation\",\n            json: true,\n            headers: standardHearders,\n            body: {\n                test_cycle: cycleId,\n                test_logs: testLogs\n            }\n        };\n\n        return request.post(opts, function (err, response, resbody) {\n\n            if (err) {\n                Promise.reject(err);\n            }\n            else {\n                emitEvent('SlackEvent', { AutomationLogUploaded: resbody });\n\n                if (response.body.type == \"AUTOMATION_TEST_LOG\") {\n                    Promise.resolve(\"Uploaded results successfully\");\n                }\n                else {\n                    emitEvent('SlackEvent', { Error: \"Wrong type\" });\n                    Promise.reject(\"Unable to upload test results\");\n                }\n            }\n        });\n    };\n\n    createLogsAndTCs()\n        .on('response', function () {\n            console.log(\"About to call Link Requirements Rule\")\n            emitEvent('LinkScenarioRequirements', payload);\n            //linkReq();\n        })\n        .on('error', function (err) {\n            emitEvent('SlackEvent', { CaughtError: err });\n        })\n}"}],"triggers":[{"id":"trigger-1","name":"SlackEvent"},{"id":"trigger-2","name":"triggerJenkins"},{"id":"trigger-3","name":"UploadPythonJUnitResults"},{"id":"trigger-4","name":"UpdateQTestWithFormattedResultsEvent"},{"id":"trigger-5","name":"LinkScenarioRequirements"},{"id":"trigger-6","name":"scenarioColors"},{"id":"trigger-7","name":"UploadJavaCucumberResults"}],"rules":[{"id":"rule-8","name":"triggerJenkins","active":true,"triggerId":"trigger-2","actionIds":["action-6"],"tags":[]},{"id":"rule-9","name":"UploadJavaCucumberResultsWithScenario","active":true,"triggerId":"trigger-4","actionIds":["action-5","action-8"],"tags":[]},{"id":"rule-10","name":"MessageSlack","active":true,"triggerId":"trigger-1","actionIds":["action-7"],"tags":[]},{"id":"rule-11","name":"ParseAndUploadPythonPyTestResults","active":true,"triggerId":"trigger-3","actionIds":["action-2"],"tags":[]},{"id":"rule-12","name":"ParseAndUploadPostmanJsonTestResults","active":true,"triggerId":"trigger-1","actionIds":["action-3"],"tags":[]},{"id":"rule-13","name":"LinkTestCasesToRequirementsWithScenario","active":true,"triggerId":"trigger-5","actionIds":["action-4"],"tags":[]},{"id":"rule-14","name":"UploadJavaCucumberResults","active":true,"triggerId":"trigger-7","actionIds":["action-1"],"tags":[]}]}